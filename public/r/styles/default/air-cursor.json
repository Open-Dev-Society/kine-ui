{
  "name": "air-cursor",
  "type": "registry:component",
  "dependencies": [
    "framer-motion",
    "@mediapipe/tasks-vision"
  ],
  "registryDependencies": [
    "kine-provider"
  ],
  "files": [
    {
      "path": "AirCursor.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport { motion, useSpring } from \"framer-motion\";\r\nimport { useKine } from \"./KineProvider\";\r\n\r\ninterface AirCursorProps {\r\n    pinchThreshold?: number;\r\n    activeColor?: string;\r\n    idleColor?: string;\r\n}\r\n\r\nexport const AirCursor: React.FC<AirCursorProps> = ({\r\n    pinchThreshold = 0.04,\r\n    activeColor = \"#3b82f6\", // Default tailwind blue-500\r\n    idleColor = \"#000000\",\r\n}) => {\r\n    const { landmarksRef, isWebcamActive } = useKine();\r\n    const [isPinching, setIsPinching] = useState(false);\r\n    const clickDebounceRef = useRef<boolean>(false);\r\n\r\n    // Smooth springs for cursor position to filter out webcam jitter\r\n    const xSpring = useSpring(0, { stiffness: 300, damping: 20 });\r\n    const ySpring = useSpring(0, { stiffness: 300, damping: 20 });\r\n    const opacitySpring = useSpring(0, { stiffness: 300, damping: 20 });\r\n\r\n    useEffect(() => {\r\n        if (!isWebcamActive) return;\r\n\r\n        let animationFrameId: number;\r\n\r\n        const loop = () => {\r\n            const landmarks = landmarksRef.current;\r\n            if (landmarks && landmarks.length > 0) {\r\n                opacitySpring.set(1);\r\n                // Grab the first hand detected\r\n                const thumbTip = landmarks[0][4];  // Thumb tip is 4\r\n                const indexTip = landmarks[0][8]; // Index finger tip is 8\r\n\r\n                // Convert normalized coordinates (0-1) to viewport pixels\r\n                // We MUST invert the X-axis because the webcam video is visually mirrored!\r\n                const windowWidth = typeof window !== \"undefined\" ? window.innerWidth : 1000;\r\n                const windowHeight = typeof window !== \"undefined\" ? window.innerHeight : 1000;\r\n\r\n                const targetX = (1 - indexTip.x) * windowWidth;\r\n                const targetY = indexTip.y * windowHeight;\r\n\r\n                xSpring.set(targetX);\r\n                ySpring.set(targetY);\r\n\r\n                // Calculate 3D Euclidean distance for pinch detection\r\n                const dx = indexTip.x - thumbTip.x;\r\n                const dy = indexTip.y - thumbTip.y;\r\n                const dz = indexTip.z - thumbTip.z;\r\n                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n\r\n                if (distance < pinchThreshold) {\r\n                    setIsPinching((currentIsPinching) => {\r\n                        if (!currentIsPinching) {\r\n                            // Fire click event if not debounced\r\n                            if (!clickDebounceRef.current) {\r\n                                clickDebounceRef.current = true;\r\n                                // Find element under cursor and trigger a simulated click\r\n                                const el = document.elementFromPoint(targetX, targetY);\r\n                                if (el && el instanceof HTMLElement) {\r\n                                    el.click();\r\n                                }\r\n                                // Simple debounce to prevent rapid-fire clicks\r\n                                setTimeout(() => {\r\n                                    clickDebounceRef.current = false;\r\n                                }, 500);\r\n                            }\r\n                            return true;\r\n                        }\r\n                        return currentIsPinching;\r\n                    });\r\n                } else {\r\n                    setIsPinching((currentIsPinching) => {\r\n                        return currentIsPinching ? false : currentIsPinching;\r\n                    });\r\n                }\r\n            } else {\r\n                opacitySpring.set(0);\r\n                setIsPinching((currentIsPinching) => {\r\n                    return currentIsPinching ? false : currentIsPinching;\r\n                });\r\n            }\r\n            animationFrameId = requestAnimationFrame(loop);\r\n        };\r\n\r\n        animationFrameId = requestAnimationFrame(loop);\r\n\r\n        return () => {\r\n            cancelAnimationFrame(animationFrameId);\r\n        };\r\n    }, [isWebcamActive, landmarksRef, pinchThreshold, xSpring, ySpring, opacitySpring]);\r\n\r\n    if (!isWebcamActive) return null;\r\n\r\n    return (\r\n        <motion.div\r\n            style={{\r\n                position: \"fixed\",\r\n                top: 0,\r\n                left: 0,\r\n                x: xSpring,\r\n                y: ySpring,\r\n                opacity: opacitySpring,\r\n                width: 32,\r\n                height: 32,\r\n                borderRadius: \"50%\",\r\n                backgroundColor: isPinching ? activeColor : idleColor,\r\n                border: \"2px solid white\",\r\n                pointerEvents: \"none\", // Prevent the cursor from blocking its own clicks!\r\n                zIndex: 99999,\r\n                translateX: \"-50%\",\r\n                translateY: \"-50%\",\r\n            }}\r\n            animate={{\r\n                scale: isPinching ? 0.8 : 1,\r\n            }}\r\n            transition={{ duration: 0.15 }}\r\n        />\r\n    );\r\n};\r\n",
      "type": "registry:component",
      "target": "components/kine/AirCursor.tsx"
    }
  ]
}