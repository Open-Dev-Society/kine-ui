{
  "name": "air-scroll",
  "type": "registry:component",
  "dependencies": [],
  "registryDependencies": [
    "kine-provider"
  ],
  "files": [
    {
      "path": "AirScroll.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport { useKine } from \"./KineProvider\";\r\n\r\ninterface AirScrollProps {\r\n    scrollSpeed?: number;\r\n    threshold?: number;\r\n}\r\n\r\nexport function AirScroll({\r\n    scrollSpeed = 5,\r\n    threshold = 0.02\r\n}: AirScrollProps) {\r\n    const { landmarksRef } = useKine();\r\n    const historyRef = useRef<number[]>([]);\r\n    const lastScrollTime = useRef<number>(0);\r\n\r\n    useEffect(() => {\r\n        let animationFrameId: number;\r\n\r\n        const loop = () => {\r\n            if (landmarksRef.current && landmarksRef.current.length > 0) {\r\n                // Focus on the first detected hand\r\n                const hand = landmarksRef.current[0];\r\n\r\n                // 0 is the wrist/base of the palm. We use this as a stable anchor for scrolling.\r\n                const palmY = hand[0].y;\r\n\r\n                historyRef.current.push(palmY);\r\n\r\n                // Keep a rolling history of 10 frames\r\n                if (historyRef.current.length > 10) {\r\n                    historyRef.current.shift();\r\n\r\n                    const oldestY = historyRef.current[0];\r\n                    const newestY = historyRef.current[historyRef.current.length - 1];\r\n\r\n                    // Calculate the vertical delta over the last 10 frames\r\n                    const deltaY = newestY - oldestY;\r\n\r\n                    // If the movement passes the noise threshold, trigger a scroll\r\n                    if (Math.abs(deltaY) > threshold) {\r\n\r\n                        // Optional constraint: Ensure the hand is \"open\" to avoid scrolling\r\n                        // while trying to pinch-to-click. \r\n                        // We check if the tip of the index (8) is far from the thumb tip (4).\r\n                        const indexTip = hand[8];\r\n                        const thumbTip = hand[4];\r\n                        const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);\r\n\r\n                        // Only scroll if they are NOT actively pinching (dist > 0.1 normalized)\r\n                        if (pinchDist > 0.1) {\r\n\r\n                            // Rate limit the scroll event slightly to prevent hyper-scrolling jitter\r\n                            const now = performance.now();\r\n                            if (now - lastScrollTime.current > 16) { // ~60 FPS cap\r\n\r\n                                // Multiply by window height to convert normalized coordinate delta to physical pixels\r\n                                // Multiply by scrollSpeed to allow user configuration of sensitivity\r\n                                const scrollAmount = deltaY * window.innerHeight * scrollSpeed;\r\n\r\n                                window.scrollBy({\r\n                                    top: scrollAmount,\r\n                                    behavior: \"auto\" // \"auto\" provides immediate tight 1:1 mapping compared to \"smooth\"\r\n                                });\r\n\r\n                                lastScrollTime.current = now;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Decay history if hand is lost\r\n                if (historyRef.current.length > 0) {\r\n                    historyRef.current.shift();\r\n                }\r\n            }\r\n\r\n            animationFrameId = requestAnimationFrame(loop);\r\n        };\r\n\r\n        loop();\r\n\r\n        return () => {\r\n            cancelAnimationFrame(animationFrameId);\r\n        };\r\n    }, [landmarksRef, scrollSpeed, threshold]);\r\n\r\n    return null; // Headless component\r\n}\r\n",
      "type": "registry:component",
      "target": "components/kine/gestures/AirScroll.tsx"
    }
  ]
}