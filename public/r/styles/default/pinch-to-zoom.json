{
  "name": "pinch-to-zoom",
  "type": "registry:component",
  "dependencies": [
    "framer-motion"
  ],
  "registryDependencies": [
    "kine-provider"
  ],
  "files": [
    {
      "path": "PinchToZoom.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport { useKine } from \"./KineProvider\";\r\nimport { motion, useSpring, useTransform } from \"framer-motion\";\r\n\r\ninterface PinchToZoomProps {\r\n    children: React.ReactNode;\r\n    minScale?: number;\r\n    maxScale?: number;\r\n    zoomSpeed?: number;\r\n}\r\n\r\nexport function PinchToZoom({\r\n    children,\r\n    minScale = 0.5,\r\n    maxScale = 5,\r\n    zoomSpeed = 8\r\n}: PinchToZoomProps) {\r\n    const { landmarksRef } = useKine();\r\n\r\n    // We use a React state to gracefully disable pointer-events if the user is zooming\r\n    // This stops them from accidentally clicking things under the image while zooming\r\n    const [isZooming, setIsZooming] = useState(false);\r\n\r\n    // Physically simulate the scale distance to smooth out tiny camera jitters\r\n    const scale = useSpring(1, {\r\n        stiffness: 400,\r\n        damping: 40,\r\n        mass: 0.8\r\n    });\r\n\r\n    const isZoomingRef = useRef(false);\r\n    const initialDistanceRef = useRef<number | null>(null);\r\n    const currentScaleRef = useRef<number>(1);\r\n\r\n    useEffect(() => {\r\n        let animationFrameId: number;\r\n\r\n        const loop = () => {\r\n            const hands = landmarksRef.current || [];\r\n\r\n            // PinchToZoom explicitly requires EXACTLY 2 hands detected by MediaPipe\r\n            if (hands.length === 2) {\r\n                const hand1 = hands[0];\r\n                const hand2 = hands[1];\r\n\r\n                const thumb1 = hand1[4];\r\n                const index1 = hand1[8];\r\n                const thumb2 = hand2[4];\r\n                const index2 = hand2[8];\r\n\r\n                // Are BOTH hands currently pinching?\r\n                const isHand1Pinching = Math.hypot(thumb1.x - index1.x, thumb1.y - index1.y) < 0.1;\r\n                const isHand2Pinching = Math.hypot(thumb2.x - index2.x, thumb2.y - index2.y) < 0.1;\r\n\r\n                if (isHand1Pinching && isHand2Pinching) {\r\n                    if (!isZoomingRef.current) {\r\n                        isZoomingRef.current = true;\r\n                        setIsZooming(true);\r\n\r\n                        // Calculate center points of each pinch lock\r\n                        const pinch1Center = { x: (thumb1.x + index1.x) / 2, y: (thumb1.y + index1.y) / 2 };\r\n                        const pinch2Center = { x: (thumb2.x + index2.x) / 2, y: (thumb2.y + index2.y) / 2 };\r\n\r\n                        // Store the initial distance to calculate future scale multipliers\r\n                        initialDistanceRef.current = Math.hypot(pinch1Center.x - pinch2Center.x, pinch1Center.y - pinch2Center.y);\r\n                    } else if (initialDistanceRef.current !== null) {\r\n\r\n                        const pinch1Center = { x: (thumb1.x + index1.x) / 2, y: (thumb1.y + index1.y) / 2 };\r\n                        const pinch2Center = { x: (thumb2.x + index2.x) / 2, y: (thumb2.y + index2.y) / 2 };\r\n                        const currentDistance = Math.hypot(pinch1Center.x - pinch2Center.x, pinch1Center.y - pinch2Center.y);\r\n\r\n                        // Calculate scale delta\r\n                        const distanceDelta = currentDistance - initialDistanceRef.current;\r\n\r\n                        // Apply speed multiplier and clamp\r\n                        const newRawScale = currentScaleRef.current + (distanceDelta * zoomSpeed);\r\n                        const clampedScale = Math.max(minScale, Math.min(newRawScale, maxScale));\r\n\r\n                        scale.set(clampedScale);\r\n\r\n                        // Re-calibrate the distance anchor dynamically to allow continuous \"ratcheting\"\r\n                        // where the user can spread, release one hand, grab again, and spread further\r\n                        initialDistanceRef.current = currentDistance;\r\n                        currentScaleRef.current = clampedScale;\r\n                    }\r\n                } else {\r\n                    // One or both hands let go of the pinch.\r\n                    if (isZoomingRef.current) {\r\n                        isZoomingRef.current = false;\r\n                        setIsZooming(false);\r\n                        initialDistanceRef.current = null;\r\n\r\n                        // Snap back to 1.0 scale if they aren't pinching anymore\r\n                        scale.set(1);\r\n                        currentScaleRef.current = 1;\r\n                    }\r\n                }\r\n            } else {\r\n                // Lost sight of 2 hands completely\r\n                if (isZoomingRef.current) {\r\n                    isZoomingRef.current = false;\r\n                    setIsZooming(false);\r\n                    initialDistanceRef.current = null;\r\n                    scale.set(1);\r\n                    currentScaleRef.current = 1;\r\n                }\r\n            }\r\n\r\n            animationFrameId = requestAnimationFrame(loop);\r\n        };\r\n\r\n        loop();\r\n\r\n        return () => {\r\n            cancelAnimationFrame(animationFrameId);\r\n        };\r\n    }, [landmarksRef, scale, minScale, maxScale, zoomSpeed]);\r\n\r\n    return (\r\n        <motion.div\r\n            style={{\r\n                scale,\r\n                // Automatically disable pointer events on chidren while actively physically scaling them\r\n                pointerEvents: isZooming ? \"none\" : \"auto\",\r\n                touchAction: \"none\"\r\n            }}\r\n            className=\"transform-gpu origin-center relative inline-block z-50\"\r\n        >\r\n            {children}\r\n        </motion.div>\r\n    );\r\n}\r\n",
      "type": "registry:component",
      "target": "components/kine/gestures/PinchToZoom.tsx"
    }
  ]
}